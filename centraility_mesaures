# centrality mesaures 

def BFS(G, s, t):
  queue = deque([s])
  visited = set()
  while queue:
    u = queue.popleft()
    if u not in visited:
      visited.add(u)
      for v in G2[u]:
        queue.append(v)
        if v == t:
          return visited
  return visited
def fun_betweenness_centrality(G):
  betweenness = defaultdict(int)
  for i, s in enumerate(G):
    if i == 10:
      break
    for j, t in enumerate(G):
      if j == 10:
        break
      if s != t:
        # Calcolo i percorsi minimi tra s e t utilizzando l'algoritmo BFS
        path = BFS(G, s, t)
        for v in path:
          betweenness[v] += 1
  # Normalizza i valori della betweenness
  n = len(G)
  for v in betweenness:
    betweenness[v] /= (n-1)*(n-2)
  return betweenness
result = fun_betweenness_centrality(G)


def fun_degree_centrality(G, node):
  num_neighbors = len(list(G.neighbors(node)))
  fun_degree_centrality = num_neighbors / (len(G) - 1)
  return fun_degree_centrality
  
  
  def fun_pagerank_centrality(G, alpha=0.85, max_iter=100, tol=1e-6):
  # Inizializza i valori di PageRank di ogni nodo con 1/n, dove n è il numero di nodi del grafo
  n = len(G)
  pagerank = {node: 1/n for node in G}
  # Itera finché non si raggiunge la convergenza o il numero massimo di iterazioni
  for i in range(max_iter):
    diff = 0
    # Calcola il nuovo valore di PageRank per ogni nodo
    for node in pagerank:
      rank = sum(pagerank[neighbor] / len(G[neighbor]) for neighbor in G[node])
      # Aggiorna il valore di PageRank del nodo utilizzando la formula di PageRank
      new_rank = (1 - alpha) / n + alpha * rank
      diff += abs(new_rank - pagerank[node])
      pagerank[node] = new_rank
    # Se la differenza è minore della soglia di tolleranza, interrompi il loop
    if diff < tol:
      break
  return pagerank
  
  
  
  def fun_closeness_centrality(G, node):
  # Inizializza una coda e un dizionario per tenere traccia della distanza di ogni nodo dal nodo in questione
  queue = deque([node])
  distances = {node: 0}

  # Esegue la ricerca in larghezza a partire dal nodo in questione
  while queue:
    current_node = queue.popleft()
    for neighbor in G[current_node]:
      if neighbor not in distances:
        distances[neighbor] = distances[current_node] + 1
        queue.append(neighbor)

  # Calcola la somma delle distanze di tutti i nodi dal nodo in questione
  total_distance = sum(distances.values())
  # Calcola la centralità di prossimità come il numero di nodi del grafo diviso dalla somma delle distanze
  closeness_centrality = len(G) / total_distance
  return closeness_centrality
